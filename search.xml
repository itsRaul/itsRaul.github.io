<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[小程序http封装]]></title>
    <url>%2F2018%2F12%2F05%2FweChat-wx-request%2F</url>
    <content type="text"><![CDATA[小程序wx.request请求封装 12345678910config.js---api_base_url:接口域名appkey:头部携带的参数const config = &#123; api_base_url: &apos;&apos;, appkey: &quot;&quot;,&#125;export &#123;config &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364http.js---import &#123;config&#125; from &apos;../config.js&apos;定义状态码返回的错误信息 const tips = &#123; 1: &apos;抱歉，出现了一个错误&apos;, 1005:&apos;appkey无效，请前往www.7yue.pro申请&apos;, 3000:&apos;期刊不存在&apos;&#125;解构class HTTP&#123; 默认GET请求方式，返回Promise request(&#123;url,data=&#123;&#125;,method=&apos;GET&apos;&#125;)&#123; return new Promise((resolve, reject)=&gt;&#123; this._request(url,resolve,reject,data, method) &#125;) &#125; _request(url,resolve, reject, data=&#123;&#125;, method=&apos;GET&apos;)&#123; wx.request(&#123; url:config.api_base_url + url, method:method, data:data, header:&#123; &apos;content-type&apos;:&apos;application/json&apos;, &apos;appkey&apos;:config.appkey &#125;, success:(res)=&gt;&#123; const code = res.statusCode.toString() if (code.startsWith(&apos;2&apos;))&#123; resolve(res.data) &#125; else&#123; reject() const error_code = res.data.error_code this._show_error(error_code) &#125; &#125;, fail:(err)=&gt;&#123; reject() this._show_error(1) &#125; &#125;) &#125; _show_error(error_code)&#123; if(!error_code)&#123; error_code = 1 &#125; const tip = tips[error_code] wx.showToast(&#123; title: tip?tip:tips[1], icon:&apos;none&apos;, duration:2000 &#125;) &#125;&#125;export &#123;HTTP&#125; 1234567891011121314151617181920212223242526272829model.js---import &#123; HTTP&#125;from &apos;http.js&apos;ES6继承class Model extends HTTP &#123; GET请求 getDetail(bid) &#123; return this.request(&#123; url: `book/$&#123;bid&#125;/detail` &#125;) &#125; POST请求 postComment(bid, comment) &#123; return this.request(&#123; url: &apos;book/add/short_comment&apos;, method: &apos;POST&apos;, data: &#123; book_id: bid, content: comment &#125; &#125;) &#125;&#125; 123456789101112使用---import &#123; Models&#125; from &apos;/models.js&apos;实例化对象const model = new Models()model.getDetail().then(res =&gt; &#123;&#125;)]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序组件]]></title>
    <url>%2F2018%2F11%2F04%2FweChat-component%2F</url>
    <content type="text"><![CDATA[小程序组件、事件与属性 组件引用1234567891011121314151617181920212223242526272829303132Component(&#123; /** * 组件的属性列表，外部暴露的属性 */ properties: &#123; like:&#123; type:Number、String、Boolean, //属性的类型，必填 value:false, //初始值，选填 observer: function (newVal, oldVal) &#123; this.setData(&#123; val:newVal &#125;) &#125; // observer属性被改变时执行的函数（可选)，不要直接去改变properties的值(发生内存泄漏)，通过data定义的数据，通过setData把properties的值赋值data定义的值 &#125; &#125;, /** * 组件的初始数据 */ data: &#123; isLike:false, val:null &#125;, /** * 组件的方法列表 */ methods: &#123; this.properties.like//访问properties的属性 &#125;&#125;) 1.微信开发者工具小程序新建Component,新建组件目录2.properties：对外属性，即如果外部的wxml文件传入数据时，会把数据设置成properties的属性。(类似vue父子组件的传值类型限定)3.data数据的状态绑定4.methods组件的方法和生命周期的使用5.只有setData才可以更新data的数据]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router的history模式]]></title>
    <url>%2F2018%2F10%2F16%2Fvue-router-history%2F</url>
    <content type="text"><![CDATA[History模式 简述1.vue-router 默认 hash 模式 ,后面带有#号，如果不要hash，可以用路由的 history 模式，后面不带#号。 2.前端处理12345const router = new VueRouter(&#123; mode: &apos;history&apos;, base:&quot;/app&quot; routes: [...]&#125;) base：应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/“。如果放在服务器app文件下面没有base设置，页面会出现空白，无法显示页面。 3.history 模式需要后端的配置支持后端配置history模式详情]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moment在vue时间格式化]]></title>
    <url>%2F2018%2F10%2F10%2Fmoment%2F</url>
    <content type="text"><![CDATA[Vue–moment时间格式插件安装和使用 moment文档安装插件1yarn add moment -S 导入使用12345678910import moment from &apos;moment&apos;filters: &#123; dateyear(time)&#123; return moment(time*1000).format(&quot;YYYY年MM月DD日&quot;) &#125;, formatDate(time) &#123; return moment(time*1000).format(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;, filters过滤器，time时间戳的形参，time为什么要乘以1000？因为我公司的后端是PHP，PHP返回的时间戳需要乘以1000,格式化的时间才准确显示。123&lt;template&gt; &lt;div&gt;&#123;&#123;item.add_time | formatDate&#125;&#125;&lt;/div&gt;&lt;/template&gt; 在vue模版时间格式化的显示]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex]]></title>
    <url>%2F2018%2F10%2F09%2Fvue-vuex%2F</url>
    <content type="text"><![CDATA[Vuex的使用 Vuex是什么Vuex是vue的全局状态管理模式，为所有组件管理状态，当多组件共享状态时，应当使用vuex，数据更好进行管理。简单说就是无论父组件还是子组件或子子组件都可以直接从vuex获取状态，vuex提供统一状态管理，更好去管理数据。 Vuex图解1.通过提交mutations去改变state状态，从而state状态渲染到视图组件上2.视图组件可以dispatch派发一个Action进行异步操作，异步操作在action里面，在action里面可以commit-mutation3.视图组件可以派发action去提交Mutations，从而改变state State1.state是vuex唯一的状态源，用一个对象包含了全部的应用层级状态。123456state.js const state = &#123; count:1&#125;export default state; 2.如何在vue组件获取vuex状态12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; 通过在根实例注册store选项，注入到根组件的所有子组件，且子组件能通过 this.$store 访问到。通过计算属性返回某个状态，每当this.$store.state.count变化的时候，都会重新求取计算属性，计算属性有缓存。 3.mapState辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余，帮助我们生成计算属性，让你少按几次键12345678import &#123; mapState &#125; from &apos;vuex&apos;export defauilt &#123; computed:&#123; ...mapState( [&apos;count&apos;] ) &#125;&#125; Getter简述Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。123getters.jsexport const count = state =&gt; state.count 访问方式1.组件中使用它12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.count &#125;&#125; 2.mapGetters辅助函数，个人比较喜欢当一种方式使用对象展开运算符将 getter 混入 computed 对象中12345678910import &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapGetters([ &apos;count&apos;, &apos;anotherGetter&apos;, ]) &#125;&#125; 如果你想将一个 getter 属性另取一个名字，使用对象形式：1234mapGetters(&#123; 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: &apos;doneTodosCount&apos;&#125;) Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。个人比较常用的一种方式 Mutation配置123mutations-types.jsexport const SET_MUTATION = &apos;export const SET_MUTATION&apos; 使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： 1234567891011mutations.jsimport * as types from &apos;./mutations-types.js&apos;const mutations = &#123; [types.SET_MUTATION](state,payload)&#123; &#125;&#125;export default mutations; state参数可以获取vuex中所有数据源，payload是提交mutations传入的数据参数。 提交mutation1.mapMutations辅助函数123456789101112import &#123; mapMutations &#125; from &apos;vuex&apos;methods:&#123; test()&#123; this.mutation(&#123; amount: 10 &#125;) &#125;, ...mapMutations(&#123; mutation:&apos;types.SET_MUTATION&apos; &#125;)&#125; 将 this.mutation() 映射为 this.$store.commit(&#39;increment&#39;)。this.mutation()提交mutation。12345678910接收payloadmutations.jsimport * as types from &apos;./mutations-types.js&apos;const mutations = &#123; [types.SET_MUTATION](state,payload)&#123; state.count = payload.amount &#125;&#125; ActionAction 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 注册简单的action12345import * as types from &apos;./mutations-types.js&apos;export const actionFn = function(&#123;commit,state&#125;,&#123;amount&#125;)&#123; commit(types.SET_MUTATION,amount)&#125; 在组件中分发 Action12345678910import &#123; mapActions &#125; from &apos;vuex&apos;methods:&#123; test()&#123; this.actionFn(&#123;amount:10&#125;) &#125;, ...mapActions([ &apos;actionFn&apos; ])&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5的支付]]></title>
    <url>%2F2018%2F10%2F01%2Fh5-pay%2F</url>
    <content type="text"><![CDATA[JSSDK微信支付、h5浏览器支付宝支付、微信h5支付 微信支付引入JS文件1http://res2.wx.qq.com/open/js/jweixin-1.4.0.js 通过config接口注入权限验证配置使用JSSDK的页面必须先配置信息，否则无法使用。配置的信息通过后端接口返回，前端调用。chooseWXPay:微信支付的接口12345678wx.config(&#123; debug: true, // 开启调试模式 appId: &apos;&apos;, // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: &apos;&apos;, // 必填，生成签名的随机串 signature: &apos;&apos;,// 必填，签名 jsApiList: [&apos;chooseWXPay&apos;] // 必填，需要使用的JS接口列表&#125;); 通过ready接口处理成功验证config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。12345678910111213141516wx.ready(function()&#123; wx.chooseWXPay(&#123; timestamp: , // 支付签名时间戳 nonceStr: , // 支付签名随机串，不长于 32 位 package:, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*） signType: &apos;MD5&apos;, // 签名方式，默认为&apos;SHA1&apos;，使用新版支付需传入&apos;MD5&apos; paySign: , // 支付签名 success: function (res) &#123; if(res.errMsg == &quot;chooseWXPay:ok&quot;)&#123; alert(&quot;支付成功&quot;) &#125;else&#123; alert(res.errMsg); &#125; &#125; &#125;);&#125;); 1.坑：当支付成功时，前端看到支付成功，有个坑可能会出现，就是后端订单的支付信息可能会显示未支付状态2.出现的原因：用户支付完成，直接退出，后端未接收到支付完成的回调3.解决方法：后端提供支付订单状态接口，在支付成功时调用后端接口来确认订单支付状态 非微信浏览器的微信h5支付12wxpay.mweb_url,直接从后台返回的URL跳转唤起微信支付window.location.href = wxpay.mweb_url 后端接口返回wxpay参数下面的mweb_url,前端跳转唤起微信支付即可，前端无需做任何处理 支付宝支付1.关于在h5浏览器的支付宝支付，前端直接调用后端接口2.后端提供接口alipay里有关于html页面，显示支付宝支付页面，继续支付和已完成支付，点击继续支付即可完成支付3.坑：后端提供的接口是否可以跳转支付页面，需要前后端联调前端处理123456res =&gt; &#123; const div = document.createElement(&apos;div&apos;); div.innerHTML = res.html; //接口返回的html document.body.appendChild(div); document.forms.alipaysubmit.submit(); &#125;]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>wx.chooseWXPay</tag>
        <tag>Alipay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2F09%2F30%2Fblog-construct%2F</url>
    <content type="text"><![CDATA[hexo + github 搭建属于自己的个人博客 准备工作1.node：安装node，到官网下载，一路安装即可，在命令行输入node -v，出现版本号安装成功。 2.git：一路安装即可，教程 3.github：程序员的交流网站，用来做博客的远程创库、域名、服务器。 (Mac系统下载Homebrew，直接在终端进行下载，brew install git、brew install node) 安装hexo框架1npm install -g hexo 初始化项目终端cd到一个选定的目录文件下(如新建一个文件夹blog)1hexo init 查看blog文件下是否存在node_modules文件夹,不在则执行如下命令1hexo install 开启hexo服务器，在浏览器打开网址http://localhost:4000，出现hexo页面1hexo s 创建github仓库1.打开github，注册账号，需要和电脑关联，在本地创建ssh key，可在百度输入github与本地电脑关联 2.创建github仓库,点击+号(New repository),新建仓库，名为用户名.github.io固定写法。(用户名就是自己github的名字) 3.Create repository创建仓库，其它不用选择 4.cd到blog文件夹，打开配置文件_config.yml1234deploy: type: git repository: https://github.com/xxx/xxx.github.io.git branch: master 你需要将repository后xxx换成你自己的用户名,浏览器输入xxx.github.io 发布文章cd到blog文件夹，执行如下命令新建文章1hexo new "postName" 名为postName的文件夹在/blog/source/_posts下。 编辑文章完成，终端cd到blog文件夹下，执行如下命令1hexo g 1hexo d 安装theme可以去搜索关于hexo的主题页，修饰自己的个人网站,在github上Clone or download地址终端cd到blog的目录下执行如下命令1git clone https://github.com/iissnan/hexo-theme-next themes/next cd到blog文件夹(每次部署文章的步骤)1hexo clean 1hexo g 1hexo d 至于更改theme内容，配置主题的网站，去修改blog/_config.yml文件和blog/themes/next/_config.yml，不要忘记冒号：加空格 绑定个人域名1.想让自己的网站看起来更有个性，可以去万网购买喜欢的域名~~ 2.购买域名后，需要进行域名解析，之前先进行域名的实名验证，填写好信息，万网有详细的教程 3.在blog/source建立CNAME的文件，没有后缀名，内容输入购买的域名，如www.xxx.com 4.在万网对域名进行解析，进入解析设置，点击添加记录，需要添加4条记录12345第一条记录：记录类型：A主机记录:www解析线路：默认记录值192.30.252.154 12345第二条记录：记录类型：A主机记录:@解析线路：默认记录值192.30.252.154 12345第三条记录：记录类型：A主机记录:www解析线路：默认记录值192.30.252.153 12345第四条记录：记录类型：A主机记录:@解析线路：默认记录值192.30.252.153 总结和说明hexo + github搭建个人网站非常简单，主要在域名解析部分，当时各种解析添加记录都无法进行解析，这4条记录一定得添加好，绑定属于自己的域名。搭建属于自己的个人网站成就感满满，也希望自己一直坚持写博客，把自己遇到的问题和所做的收获一点一滴记录起来。明天是国庆节，国庆节快乐！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么写博客]]></title>
    <url>%2F2018%2F09%2F28%2Fblog-start%2F</url>
    <content type="text"><![CDATA[为什么坚持写博客? 原因 这个博客是由我自己一点点去搭建的，其中也遇到了不少麻烦，特别是在域名解析部分。 为什么要去搭建一个博客呢？可以看看自己的轨迹，做过什么，不忘处心，不遗失自己。 之前一直有想在博客园去写博客，但发现自己写不出东西来～～～，总之就是下不了笔。 我自己搭建的博客就是想把自己对前端或其它领域某些知识点自己思考写出来，积累下来。 有很多事情你以为你知道，其实你什么都不知道。 我的理解 未来自己写博客的过程中，对某个知识点进行比较全的解析，怎么来的？用在哪里？了解其原理。 用心去写，希望在多年以后回过头来看，原来曾经自己写得这么“傻逼”。 这是第一篇文章，以后慢慢来写，因为菜，所以好好学习、天天向上。 下一篇想写个人博客的搭建！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
