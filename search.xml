<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JavaScript的作用域和变量提升、函数声明]]></title>
    <url>%2F2019%2F01%2F03%2Fjs-shangxiawen%2F</url>
    <content type="text"><![CDATA[什么是作用域 作用域就是指程序源代码定义变量的区域。 作用域规定如何查找变量，确定对当前执行代码对变量对访问权限。123456789101112var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar(); 首先是bar()函数执行，在bar()函数内部foo()函数执行，先在foo函数对当前作用域进行查找，如果没有，则查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 顺序执行123456789101112131415var foo = function () &#123; console.log(&apos;foo1&apos;);&#125;foo(); // foo1var foo = function () &#123; console.log(&apos;foo2&apos;);&#125;foo(); // foo2 123456789101112131415function foo() &#123; console.log(&apos;foo1&apos;);&#125;foo(); // foo2function foo() &#123; console.log(&apos;foo2&apos;);&#125;foo(); // foo2 JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。 变量提升 通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。 如果在当前作用域存在此声明对变量，无论它在什么地方声明，引用此变量时就会在当前作用域中查找，不会去外层作用域了。 12345678910var foo = 3;function hoistVariable() &#123; var foo = foo || 5; console.log(foo); // 5&#125;hoistVariable(); 虽然外层作用域有个foo变量，但函数内是不会去引用的。先在当前作用域寻找foo变量，如果当前作用域foo不存在，则通过作用域链往上继续找foo变量，如果继续不存在而又未定义则报错。 函数提升 为什么函数可以在声明之前就可以调用，并且跟变量声明不同的是，它还能得到正确的结果，其实引擎是把函数声明整个地提升到了当前作用域的顶部 123456789 function hoistFunction() &#123; foo(); // output: I am hoisted function foo() &#123; console.log(&apos;I am hoisted&apos;); &#125;&#125;hoistFunction(); 如果在同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明： 12345678910111213 function hoistFunction() &#123; function foo() &#123; console.log(1); &#125; foo(); // output: 2 function foo() &#123; console.log(2); &#125;&#125;hoistFunction(); 函数声明和函数表达式 1234567891011121314// 函数声明function foo() &#123; console.log(&apos;function declaration&apos;);&#125;// 匿名函数表达式var foo = function() &#123; console.log(&apos;anonymous function expression&apos;);&#125;;// 具名函数表达式var foo = function bar() &#123; console.log(&apos;named function expression&apos;);&#125;; 匿名函数表达式，其实是将一个不带名字的函数声明赋值给了一个变量， 具名函数表达式，则是带名字的函数赋值给一个变量，需要注意到是，这个函数名只能在此函数内部使用。 函数表达式可以通过变量访问，所以也存在变量提升同样的效果。 函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 的 async/await]]></title>
    <url>%2F2018%2F12%2F28%2Fasync%2F</url>
    <content type="text"><![CDATA[什么是async、await async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 async1.async用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 写一个async 函数123async function test() &#123; return &quot;hello world&quot;&#125; 2.语法就是在函数前面加上async关键字，用来表示它是异步的，怎么调用呢？async 函数也是函数，平时我们怎么使用函数就怎么使用它，直接加括号调用就可以了，为了表示它没有阻塞它后面代码的执行。1234567console.log(test())//输出的是一个Promisea对象Promise__proto__: Promise[[PromiseStatus]]: &quot;resolved&quot;[[PromiseValue]]: &quot;hell&quot; 3.async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 await1.一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。 2.async函数返回的是一个Promise对象，所以await可以用于等待一个async函数的返回值，await就是等待async的返回值。 1234567891011function test1() &#123; reuturn &quot;test1&quot;&#125;function test2() &#123; reuturn &quot;test2&quot;&#125;async function test() &#123; const v1 = await test1(); const v2 = await test2();&#125;test() 3.async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 async/await 干了啥1.async会将其后的函数的返回值封装成一个Promise对象，而await会等待这个Promise完成，并将其resolve的结果返回出来。 2.async/await 的优势在于处理 then 链，单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了123456789101112131415161718192021222324/** * 传入参数 n，表示这个函数执行的时间（毫秒） * 执行的结果是 n + 200，这个值将用于下一步骤 */function takeLongTime(n) &#123; return new Promise(resolve =&gt; &#123; setTimeout(() =&gt; resolve(n + 200), n); &#125;);&#125;function step1(n) &#123; console.log(`step1 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step2(n) &#123; console.log(`step2 with $&#123;n&#125;`); return takeLongTime(n);&#125;function step3(n) &#123; console.log(`step3 with $&#123;n&#125;`); return takeLongTime(n);&#125; 现在用 Promise 方式来实现这三个步骤的处理12345678910111213function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; step1(time1) .then(time2 =&gt; step2(time2)) .then(time3 =&gt; step3(time3)) .then(result =&gt; &#123; console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;); &#125;);&#125;doIt(); 用 async/await 来实现1234567891011async function doIt() &#123; console.time(&quot;doIt&quot;); const time1 = 300; const time2 = await step1(time1); const time3 = await step2(time2); const result = await step3(time3); console.log(`result is $&#123;result&#125;`); console.timeEnd(&quot;doIt&quot;);&#125;doIt(); 捕捉错误既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。1234567891011const start = async function () &#123; try &#123; console.log(&apos;start&apos;); await sleep(3000); // 这里得到了一个返回错误 // 所以以下代码不会被执行了 console.log(&apos;end&apos;); &#125; catch (err) &#123; console.log(err); // 这里捕捉到错误 `error` &#125;&#125;;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序http封装]]></title>
    <url>%2F2018%2F12%2F05%2FweChat-wx-request%2F</url>
    <content type="text"><![CDATA[小程序wx.request请求封装 12345678910config.js---api_base_url:接口域名appkey:头部携带的参数const config = &#123; api_base_url: &apos;&apos;, appkey: &quot;&quot;,&#125;export &#123;config &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364http.js---import &#123;config&#125; from &apos;../config.js&apos;定义状态码返回的错误信息 const tips = &#123; 1: &apos;抱歉，出现了一个错误&apos;, 1005:&apos;appkey无效，请前往www.7yue.pro申请&apos;, 3000:&apos;期刊不存在&apos;&#125;解构class HTTP&#123; 默认GET请求方式，返回Promise request(&#123;url,data=&#123;&#125;,method=&apos;GET&apos;&#125;)&#123; return new Promise((resolve, reject)=&gt;&#123; this._request(url,resolve,reject,data, method) &#125;) &#125; _request(url,resolve, reject, data=&#123;&#125;, method=&apos;GET&apos;)&#123; wx.request(&#123; url:config.api_base_url + url, method:method, data:data, header:&#123; &apos;content-type&apos;:&apos;application/json&apos;, &apos;appkey&apos;:config.appkey &#125;, success:(res)=&gt;&#123; const code = res.statusCode.toString() if (code.startsWith(&apos;2&apos;))&#123; resolve(res.data) &#125; else&#123; reject() const error_code = res.data.error_code this._show_error(error_code) &#125; &#125;, fail:(err)=&gt;&#123; reject() this._show_error(1) &#125; &#125;) &#125; _show_error(error_code)&#123; if(!error_code)&#123; error_code = 1 &#125; const tip = tips[error_code] wx.showToast(&#123; title: tip?tip:tips[1], icon:&apos;none&apos;, duration:2000 &#125;) &#125;&#125;export &#123;HTTP&#125; 1234567891011121314151617181920212223242526272829model.js---import &#123; HTTP&#125;from &apos;http.js&apos;ES6继承class Model extends HTTP &#123; GET请求 getDetail(bid) &#123; return this.request(&#123; url: `book/$&#123;bid&#125;/detail` &#125;) &#125; POST请求 postComment(bid, comment) &#123; return this.request(&#123; url: &apos;book/add/short_comment&apos;, method: &apos;POST&apos;, data: &#123; book_id: bid, content: comment &#125; &#125;) &#125;&#125; 123456789101112使用---import &#123; Models&#125; from &apos;/models.js&apos;实例化对象const model = new Models()model.getDetail().then(res =&gt; &#123;&#125;)]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小程序组件]]></title>
    <url>%2F2018%2F11%2F04%2FweChat-component%2F</url>
    <content type="text"><![CDATA[小程序组件、事件与属性 组件引用1234567891011121314151617181920212223242526272829303132Component(&#123; /** * 组件的属性列表，外部暴露的属性 */ properties: &#123; like:&#123; type:Number、String、Boolean, //属性的类型，必填 value:false, //初始值，选填 observer: function (newVal, oldVal) &#123; this.setData(&#123; val:newVal &#125;) &#125; // observer属性被改变时执行的函数（可选)，不要直接去改变properties的值(发生内存泄漏)，通过data定义的数据，通过setData把properties的值赋值data定义的值 &#125; &#125;, /** * 组件的初始数据 */ data: &#123; isLike:false, val:null &#125;, /** * 组件的方法列表 */ methods: &#123; this.properties.like//访问properties的属性 &#125;&#125;) 1.微信开发者工具小程序新建Component,新建组件目录2.properties：对外属性，即如果外部的wxml文件传入数据时，会把数据设置成properties的属性。(类似vue父子组件的传值类型限定)3.data数据的状态绑定4.methods组件的方法和生命周期的使用5.只有setData才可以更新data的数据]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router的history模式]]></title>
    <url>%2F2018%2F10%2F16%2Fvue-router-history%2F</url>
    <content type="text"><![CDATA[History模式 简述1.vue-router 默认 hash 模式 ,后面带有#号，如果不要hash，可以用路由的 history 模式，后面不带#号。 2.前端处理12345const router = new VueRouter(&#123; mode: &apos;history&apos;, base:&quot;/app&quot; routes: [...]&#125;) base：应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/“。如果放在服务器app文件下面没有base设置，页面会出现空白，无法显示页面。 3.history 模式需要后端的配置支持后端配置history模式详情]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[moment在vue时间格式化]]></title>
    <url>%2F2018%2F10%2F10%2Fmoment%2F</url>
    <content type="text"><![CDATA[Vue–moment时间格式插件安装和使用 moment文档安装插件1yarn add moment -S 导入使用12345678910import moment from &apos;moment&apos;filters: &#123; dateyear(time)&#123; return moment(time*1000).format(&quot;YYYY年MM月DD日&quot;) &#125;, formatDate(time) &#123; return moment(time*1000).format(&quot;YYYY-MM-DD HH:mm:ss&quot;) &#125;&#125;, filters过滤器，time时间戳的形参，time为什么要乘以1000？因为我公司的后端是PHP，PHP返回的时间戳需要乘以1000,格式化的时间才准确显示。123&lt;template&gt; &lt;div&gt;&#123;&#123;item.add_time | formatDate&#125;&#125;&lt;/div&gt;&lt;/template&gt; 在vue模版时间格式化的显示]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex]]></title>
    <url>%2F2018%2F10%2F09%2Fvue-vuex%2F</url>
    <content type="text"><![CDATA[Vuex的使用 Vuex是什么Vuex是vue的全局状态管理模式，为所有组件管理状态，当多组件共享状态时，应当使用vuex，数据更好进行管理。简单说就是无论父组件还是子组件或子子组件都可以直接从vuex获取状态，vuex提供统一状态管理，更好去管理数据。 Vuex图解1.通过提交mutations去改变state状态，从而state状态渲染到视图组件上2.视图组件可以dispatch派发一个Action进行异步操作，异步操作在action里面，在action里面可以commit-mutation3.视图组件可以派发action去提交Mutations，从而改变state State1.state是vuex唯一的状态源，用一个对象包含了全部的应用层级状态。123456state.js const state = &#123; count:1&#125;export default state; 2.如何在vue组件获取vuex状态12345678const Counter = &#123; template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`, computed: &#123; count () &#123; return this.$store.state.count &#125; &#125;&#125; 通过在根实例注册store选项，注入到根组件的所有子组件，且子组件能通过 this.$store 访问到。通过计算属性返回某个状态，每当this.$store.state.count变化的时候，都会重新求取计算属性，计算属性有缓存。 3.mapState辅助函数当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余，帮助我们生成计算属性，让你少按几次键12345678import &#123; mapState &#125; from &apos;vuex&apos;export defauilt &#123; computed:&#123; ...mapState( [&apos;count&apos;] ) &#125;&#125; Getter简述Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。123getters.jsexport const count = state =&gt; state.count 访问方式1.组件中使用它12345computed: &#123; doneTodosCount () &#123; return this.$store.getters.count &#125;&#125; 2.mapGetters辅助函数，个人比较喜欢当一种方式使用对象展开运算符将 getter 混入 computed 对象中12345678910import &#123; mapGetters &#125; from &apos;vuex&apos;export default &#123; computed: &#123; ...mapGetters([ &apos;count&apos;, &apos;anotherGetter&apos;, ]) &#125;&#125; 如果你想将一个 getter 属性另取一个名字，使用对象形式：1234mapGetters(&#123; 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount` doneCount: &apos;doneTodosCount&apos;&#125;) Mutation更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。个人比较常用的一种方式 Mutation配置123mutations-types.jsexport const SET_MUTATION = &apos;export const SET_MUTATION&apos; 使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然： 1234567891011mutations.jsimport * as types from &apos;./mutations-types.js&apos;const mutations = &#123; [types.SET_MUTATION](state,payload)&#123; &#125;&#125;export default mutations; state参数可以获取vuex中所有数据源，payload是提交mutations传入的数据参数。 提交mutation1.mapMutations辅助函数123456789101112import &#123; mapMutations &#125; from &apos;vuex&apos;methods:&#123; test()&#123; this.mutation(&#123; amount: 10 &#125;) &#125;, ...mapMutations(&#123; mutation:&apos;types.SET_MUTATION&apos; &#125;)&#125; 将 this.mutation() 映射为 this.$store.commit(&#39;increment&#39;)。this.mutation()提交mutation。12345678910接收payloadmutations.jsimport * as types from &apos;./mutations-types.js&apos;const mutations = &#123; [types.SET_MUTATION](state,payload)&#123; state.count = payload.amount &#125;&#125; ActionAction 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 注册简单的action12345import * as types from &apos;./mutations-types.js&apos;export const actionFn = function(&#123;commit,state&#125;,&#123;amount&#125;)&#123; commit(types.SET_MUTATION,amount)&#125; 在组件中分发 Action12345678910import &#123; mapActions &#125; from &apos;vuex&apos;methods:&#123; test()&#123; this.actionFn(&#123;amount:10&#125;) &#125;, ...mapActions([ &apos;actionFn&apos; ])&#125;]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[H5的支付]]></title>
    <url>%2F2018%2F10%2F01%2Fh5-pay%2F</url>
    <content type="text"><![CDATA[JSSDK微信支付、h5浏览器支付宝支付、微信h5支付 微信支付引入JS文件1http://res2.wx.qq.com/open/js/jweixin-1.4.0.js 通过config接口注入权限验证配置使用JSSDK的页面必须先配置信息，否则无法使用。配置的信息通过后端接口返回，前端调用。chooseWXPay:微信支付的接口12345678wx.config(&#123; debug: true, // 开启调试模式 appId: &apos;&apos;, // 必填，公众号的唯一标识 timestamp: , // 必填，生成签名的时间戳 nonceStr: &apos;&apos;, // 必填，生成签名的随机串 signature: &apos;&apos;,// 必填，签名 jsApiList: [&apos;chooseWXPay&apos;] // 必填，需要使用的JS接口列表&#125;); 通过ready接口处理成功验证config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。12345678910111213141516wx.ready(function()&#123; wx.chooseWXPay(&#123; timestamp: , // 支付签名时间戳 nonceStr: , // 支付签名随机串，不长于 32 位 package:, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\*\*\*） signType: &apos;MD5&apos;, // 签名方式，默认为&apos;SHA1&apos;，使用新版支付需传入&apos;MD5&apos; paySign: , // 支付签名 success: function (res) &#123; if(res.errMsg == &quot;chooseWXPay:ok&quot;)&#123; alert(&quot;支付成功&quot;) &#125;else&#123; alert(res.errMsg); &#125; &#125; &#125;);&#125;); 1.坑：当支付成功时，前端看到支付成功，有个坑可能会出现，就是后端订单的支付信息可能会显示未支付状态2.出现的原因：用户支付完成，直接退出，后端未接收到支付完成的回调3.解决方法：后端提供支付订单状态接口，在支付成功时调用后端接口来确认订单支付状态 非微信浏览器的微信h5支付12wxpay.mweb_url,直接从后台返回的URL跳转唤起微信支付window.location.href = wxpay.mweb_url 后端接口返回wxpay参数下面的mweb_url,前端跳转唤起微信支付即可，前端无需做任何处理 支付宝支付1.关于在h5浏览器的支付宝支付，前端直接调用后端接口2.后端提供接口alipay里有关于html页面，显示支付宝支付页面，继续支付和已完成支付，点击继续支付即可完成支付3.坑：后端提供的接口是否可以跳转支付页面，需要前后端联调前端处理123456res =&gt; &#123; const div = document.createElement(&apos;div&apos;); div.innerHTML = res.html; //接口返回的html document.body.appendChild(div); document.forms.alipaysubmit.submit(); &#125;]]></content>
      <categories>
        <category>H5</category>
      </categories>
      <tags>
        <tag>wx.chooseWXPay</tag>
        <tag>Alipay</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建个人博客]]></title>
    <url>%2F2018%2F09%2F30%2Fblog-construct%2F</url>
    <content type="text"><![CDATA[hexo + github 搭建属于自己的个人博客 准备工作1.node：安装node，到官网下载，一路安装即可，在命令行输入node -v，出现版本号安装成功。 2.git：一路安装即可，教程 3.github：程序员的交流网站，用来做博客的远程创库、域名、服务器。 (Mac系统下载Homebrew，直接在终端进行下载，brew install git、brew install node) 安装hexo框架1npm install -g hexo 初始化项目终端cd到一个选定的目录文件下(如新建一个文件夹blog)1hexo init 查看blog文件下是否存在node_modules文件夹,不在则执行如下命令1hexo install 开启hexo服务器，在浏览器打开网址http://localhost:4000，出现hexo页面1hexo s 创建github仓库1.打开github，注册账号，需要和电脑关联，在本地创建ssh key，可在百度输入github与本地电脑关联 2.创建github仓库,点击+号(New repository),新建仓库，名为用户名.github.io固定写法。(用户名就是自己github的名字) 3.Create repository创建仓库，其它不用选择 4.cd到blog文件夹，打开配置文件_config.yml1234deploy: type: git repository: https://github.com/xxx/xxx.github.io.git branch: master 你需要将repository后xxx换成你自己的用户名,浏览器输入xxx.github.io 发布文章cd到blog文件夹，执行如下命令新建文章1hexo new "postName" 名为postName的文件夹在/blog/source/_posts下。 编辑文章完成，终端cd到blog文件夹下，执行如下命令1hexo g 1hexo d 安装theme可以去搜索关于hexo的主题页，修饰自己的个人网站,在github上Clone or download地址终端cd到blog的目录下执行如下命令1git clone https://github.com/iissnan/hexo-theme-next themes/next cd到blog文件夹(每次部署文章的步骤)1hexo clean 1hexo g 1hexo d 至于更改theme内容，配置主题的网站，去修改blog/_config.yml文件和blog/themes/next/_config.yml，不要忘记冒号：加空格 绑定个人域名1.想让自己的网站看起来更有个性，可以去万网购买喜欢的域名~~ 2.购买域名后，需要进行域名解析，之前先进行域名的实名验证，填写好信息，万网有详细的教程 3.在blog/source建立CNAME的文件，没有后缀名，内容输入购买的域名，如www.xxx.com 4.在万网对域名进行解析，进入解析设置，点击添加记录，需要添加4条记录12345第一条记录：记录类型：A主机记录:www解析线路：默认记录值192.30.252.154 12345第二条记录：记录类型：A主机记录:@解析线路：默认记录值192.30.252.154 12345第三条记录：记录类型：A主机记录:www解析线路：默认记录值192.30.252.153 12345第四条记录：记录类型：A主机记录:@解析线路：默认记录值192.30.252.153 总结和说明hexo + github搭建个人网站非常简单，主要在域名解析部分，当时各种解析添加记录都无法进行解析，这4条记录一定得添加好，绑定属于自己的域名。搭建属于自己的个人网站成就感满满，也希望自己一直坚持写博客，把自己遇到的问题和所做的收获一点一滴记录起来。明天是国庆节，国庆节快乐！！！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么写博客]]></title>
    <url>%2F2018%2F09%2F28%2Fblog-start%2F</url>
    <content type="text"><![CDATA[为什么坚持写博客? 原因 这个博客是由我自己一点点去搭建的，其中也遇到了不少麻烦，特别是在域名解析部分。 为什么要去搭建一个博客呢？可以看看自己的轨迹，做过什么，不忘处心，不遗失自己。 之前一直有想在博客园去写博客，但发现自己写不出东西来～～～，总之就是下不了笔。 我自己搭建的博客就是想把自己对前端或其它领域某些知识点自己思考写出来，积累下来。 有很多事情你以为你知道，其实你什么都不知道。 我的理解 未来自己写博客的过程中，对某个知识点进行比较全的解析，怎么来的？用在哪里？了解其原理。 用心去写，希望在多年以后回过头来看，原来曾经自己写得这么“傻逼”。 这是第一篇文章，以后慢慢来写，因为菜，所以好好学习、天天向上。 下一篇想写个人博客的搭建！]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
